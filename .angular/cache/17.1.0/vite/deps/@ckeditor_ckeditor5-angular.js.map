{
  "version": 3,
  "sources": ["../../../../../node_modules/@ckeditor/ckeditor5-watchdog/src/watchdog.js", "../../../../../node_modules/@ckeditor/ckeditor5-watchdog/src/utils/getsubnodes.js", "../../../../../node_modules/@ckeditor/ckeditor5-watchdog/src/utils/areconnectedthroughproperties.js", "../../../../../node_modules/@ckeditor/ckeditor5-watchdog/src/editorwatchdog.js", "../../../../../node_modules/@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js", "../../../../../node_modules/@ckeditor/ckeditor5-angular/fesm2020/ckeditor-ckeditor5-angular.mjs"],
  "sourcesContent": ["/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * An abstract watchdog class that handles most of the error handling process and the state of the underlying component.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and how to use it.\n *\n * @internal\n */\nexport default class Watchdog {\n    /**\n     * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.\n     */\n    constructor(config) {\n        /**\n         * An array of crashes saved as an object with the following properties:\n         *\n         * * `message`: `String`,\n         * * `stack`: `String`,\n         * * `date`: `Number`,\n         * * `filename`: `String | undefined`,\n         * * `lineno`: `Number | undefined`,\n         * * `colno`: `Number | undefined`,\n         */\n        this.crashes = [];\n        /**\n         * Specifies the state of the item watched by the watchdog. The state can be one of the following values:\n         *\n         * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.\n         * * `ready` &ndash; A state when the user can interact with the item.\n         * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`\n         * depending on how many and how frequent errors have been caught recently.\n         * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,\n         * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.\n         */\n        this.state = 'initializing';\n        /**\n         * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular\n         * approaches like `sinon.useFakeTimers()` do not work well with error handling.\n         */\n        this._now = Date.now;\n        this.crashes = [];\n        this._crashNumberLimit = typeof config.crashNumberLimit === 'number' ? config.crashNumberLimit : 3;\n        this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === 'number' ? config.minimumNonErrorTimePeriod : 5000;\n        this._boundErrorHandler = evt => {\n            // `evt.error` is exposed by EventError while `evt.reason` is available in PromiseRejectionEvent.\n            const error = 'error' in evt ? evt.error : evt.reason;\n            // Note that `evt.reason` might be everything that is in the promise rejection.\n            // Similarly everything that is thrown lands in `evt.error`.\n            if (error instanceof Error) {\n                this._handleError(error, evt);\n            }\n        };\n        this._listeners = {};\n        if (!this._restart) {\n            throw new Error('The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. ' +\n                'Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.');\n        }\n    }\n    /**\n     * Destroys the watchdog and releases the resources.\n     */\n    destroy() {\n        this._stopErrorHandling();\n        this._listeners = {};\n    }\n    /**\n     * Starts listening to a specific event name by registering a callback that will be executed\n     * whenever an event with a given name fires.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     *\n     * @param eventName The event name.\n     * @param callback A callback which will be added to event listeners.\n     */\n    on(eventName, callback) {\n        if (!this._listeners[eventName]) {\n            this._listeners[eventName] = [];\n        }\n        this._listeners[eventName].push(callback);\n    }\n    /**\n     * Stops listening to the specified event name by removing the callback from event listeners.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     *\n     * @param eventName The event name.\n     * @param callback A callback which will be removed from event listeners.\n     */\n    off(eventName, callback) {\n        this._listeners[eventName] = this._listeners[eventName]\n            .filter(cb => cb !== callback);\n    }\n    /**\n     * Fires an event with a given event name and arguments.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     */\n    _fire(eventName, ...args) {\n        const callbacks = this._listeners[eventName] || [];\n        for (const callback of callbacks) {\n            callback.apply(this, [null, ...args]);\n        }\n    }\n    /**\n     * Starts error handling by attaching global error handlers.\n     */\n    _startErrorHandling() {\n        window.addEventListener('error', this._boundErrorHandler);\n        window.addEventListener('unhandledrejection', this._boundErrorHandler);\n    }\n    /**\n     * Stops error handling by detaching global error handlers.\n     */\n    _stopErrorHandling() {\n        window.removeEventListener('error', this._boundErrorHandler);\n        window.removeEventListener('unhandledrejection', this._boundErrorHandler);\n    }\n    /**\n     * Checks if an error comes from the watched item and restarts it.\n     * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.\n     *\n     * @fires error\n     * @param error Error.\n     * @param evt An error event.\n     */\n    _handleError(error, evt) {\n        // @if CK_DEBUG // const err = error as CKEditorError;\n        // @if CK_DEBUG // if ( err.is && err.is( 'CKEditorError' ) && err.context === undefined ) {\n        // @if CK_DEBUG // console.warn( 'The error is missing its context and Watchdog cannot restart the proper item.' );\n        // @if CK_DEBUG // }\n        if (this._shouldReactToError(error)) {\n            this.crashes.push({\n                message: error.message,\n                stack: error.stack,\n                // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events\n                filename: evt instanceof ErrorEvent ? evt.filename : undefined,\n                lineno: evt instanceof ErrorEvent ? evt.lineno : undefined,\n                colno: evt instanceof ErrorEvent ? evt.colno : undefined,\n                date: this._now()\n            });\n            const causesRestart = this._shouldRestart();\n            this.state = 'crashed';\n            this._fire('stateChange');\n            this._fire('error', { error, causesRestart });\n            if (causesRestart) {\n                this._restart();\n            }\n            else {\n                this.state = 'crashedPermanently';\n                this._fire('stateChange');\n            }\n        }\n    }\n    /**\n     * Checks whether an error should be handled by the watchdog.\n     *\n     * @param error An error that was caught by the error handling process.\n     */\n    _shouldReactToError(error) {\n        return (error.is &&\n            error.is('CKEditorError') &&\n            error.context !== undefined &&\n            // In some cases the watched item should not be restarted - e.g. during the item initialization.\n            // That's why the `null` was introduced as a correct error context which does cause restarting.\n            error.context !== null &&\n            // Do not react to errors if the watchdog is in states other than `ready`.\n            this.state === 'ready' &&\n            this._isErrorComingFromThisItem(error));\n    }\n    /**\n     * Checks if the watchdog should restart the underlying item.\n     */\n    _shouldRestart() {\n        if (this.crashes.length <= this._crashNumberLimit) {\n            return true;\n        }\n        const lastErrorTime = this.crashes[this.crashes.length - 1].date;\n        const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;\n        const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;\n        return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module watchdog/utils/getsubnodes\n */\n/* globals EventTarget, Event */\nexport default function getSubNodes(head, excludedProperties = new Set()) {\n    const nodes = [head];\n    // @if CK_DEBUG_WATCHDOG // const prevNodeMap = new Map();\n    // Nodes are stored to prevent infinite looping.\n    const subNodes = new Set();\n    let nodeIndex = 0;\n    while (nodes.length > nodeIndex) {\n        // Incrementing the iterator is much faster than changing size of the array with Array.prototype.shift().\n        const node = nodes[nodeIndex++];\n        if (subNodes.has(node) || !shouldNodeBeIncluded(node) || excludedProperties.has(node)) {\n            continue;\n        }\n        subNodes.add(node);\n        // Handle arrays, maps, sets, custom collections that implements `[ Symbol.iterator ]()`, etc.\n        if (Symbol.iterator in node) {\n            // The custom editor iterators might cause some problems if the editor is crashed.\n            try {\n                for (const n of node) {\n                    nodes.push(n);\n                    // @if CK_DEBUG_WATCHDOG // if ( !prevNodeMap.has( n ) ) {\n                    // @if CK_DEBUG_WATCHDOG // \tprevNodeMap.set( n, node );\n                    // @if CK_DEBUG_WATCHDOG // }\n                }\n            }\n            catch (err) {\n                // Do not log errors for broken structures\n                // since we are in the error handling process already.\n                // eslint-disable-line no-empty\n            }\n        }\n        else {\n            for (const key in node) {\n                // We share a reference via the protobuf library within the editors,\n                // hence the shared value should be skipped. Although, it's not a perfect\n                // solution since new places like that might occur in the future.\n                if (key === 'defaultValue') {\n                    continue;\n                }\n                nodes.push(node[key]);\n                // @if CK_DEBUG_WATCHDOG // if ( !prevNodeMap.has( node[ key ] ) ) {\n                // @if CK_DEBUG_WATCHDOG // \tprevNodeMap.set( node[ key ], node );\n                // @if CK_DEBUG_WATCHDOG // }\n            }\n        }\n    }\n    // @if CK_DEBUG_WATCHDOG // return { subNodes, prevNodeMap } as any;\n    return subNodes;\n}\nfunction shouldNodeBeIncluded(node) {\n    const type = Object.prototype.toString.call(node);\n    const typeOfNode = typeof node;\n    return !(typeOfNode === 'number' ||\n        typeOfNode === 'boolean' ||\n        typeOfNode === 'string' ||\n        typeOfNode === 'symbol' ||\n        typeOfNode === 'function' ||\n        type === '[object Date]' ||\n        type === '[object RegExp]' ||\n        type === '[object Module]' ||\n        node === undefined ||\n        node === null ||\n        // This flag is meant to exclude singletons shared across editor instances. So when an error is thrown in one editor,\n        // the other editors connected through the reference to the same singleton are not restarted. This is a temporary workaround\n        // until a better solution is found.\n        // More in https://github.com/ckeditor/ckeditor5/issues/12292.\n        node._watchdogExcluded ||\n        // Skip native DOM objects, e.g. Window, nodes, events, etc.\n        node instanceof EventTarget ||\n        node instanceof Event);\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module watchdog/utils/areconnectedthroughproperties\n */\n/* globals console */\nimport getSubNodes from './getsubnodes';\n/**\n * Traverses both structures to find out whether there is a reference that is shared between both structures.\n */\nexport default function areConnectedThroughProperties(target1, target2, excludedNodes = new Set()) {\n    if (target1 === target2 && isObject(target1)) {\n        return true;\n    }\n    // @if CK_DEBUG_WATCHDOG // return checkConnectionBetweenProps( target1, target2, excludedNodes );\n    const subNodes1 = getSubNodes(target1, excludedNodes);\n    const subNodes2 = getSubNodes(target2, excludedNodes);\n    for (const node of subNodes1) {\n        if (subNodes2.has(node)) {\n            return true;\n        }\n    }\n    return false;\n}\n/* istanbul ignore next -- @preserve */\n// eslint-disable-next-line\nfunction checkConnectionBetweenProps(target1, target2, excludedNodes) {\n    const { subNodes: subNodes1, prevNodeMap: prevNodeMap1 } = getSubNodes(target1, excludedNodes.subNodes);\n    const { subNodes: subNodes2, prevNodeMap: prevNodeMap2 } = getSubNodes(target2, excludedNodes.subNodes);\n    for (const sharedNode of subNodes1) {\n        if (subNodes2.has(sharedNode)) {\n            const connection = [];\n            connection.push(sharedNode);\n            let node = prevNodeMap1.get(sharedNode);\n            while (node && node !== target1) {\n                connection.push(node);\n                node = prevNodeMap1.get(node);\n            }\n            node = prevNodeMap2.get(sharedNode);\n            while (node && node !== target2) {\n                connection.unshift(node);\n                node = prevNodeMap2.get(node);\n            }\n            console.log('--------');\n            console.log({ target1 });\n            console.log({ sharedNode });\n            console.log({ target2 });\n            console.log({ connection });\n            return true;\n        }\n    }\n    return false;\n}\nfunction isObject(structure) {\n    return typeof structure === 'object' && structure !== null;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties';\nimport Watchdog from './watchdog';\nimport { throttle, cloneDeepWith, isElement } from 'lodash-es';\n/**\n * A watchdog for CKEditor 5 editors.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\nexport default class EditorWatchdog extends Watchdog {\n    /**\n     * @param Editor The editor class.\n     * @param watchdogConfig The watchdog plugin configuration.\n     */\n    constructor(Editor, watchdogConfig = {}) {\n        super(watchdogConfig);\n        /**\n         * The current editor instance.\n         */\n        this._editor = null;\n        /**\n         * Specifies whether the editor was initialized using document data (`true`) or HTML elements (`false`).\n         */\n        this._initUsingData = true;\n        /**\n         * The latest record of the editor editable elements. Used to restart the editor.\n         */\n        this._editables = {};\n        // this._editorClass = Editor;\n        this._throttledSave = throttle(this._save.bind(this), typeof watchdogConfig.saveInterval === 'number' ? watchdogConfig.saveInterval : 5000);\n        // Set default creator and destructor functions:\n        if (Editor) {\n            this._creator = ((elementOrData, config) => Editor.create(elementOrData, config));\n        }\n        this._destructor = editor => editor.destroy();\n    }\n    /**\n     * The current editor instance.\n     */\n    get editor() {\n        return this._editor;\n    }\n    /**\n     * @internal\n     */\n    get _item() {\n        return this._editor;\n    }\n    /**\n     * Sets the function that is responsible for the editor creation.\n     * It expects a function that should return a promise.\n     *\n     * ```ts\n     * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );\n     * ```\n     */\n    setCreator(creator) {\n        this._creator = creator;\n    }\n    /**\n     * Sets the function that is responsible for the editor destruction.\n     * Overrides the default destruction function, which destroys only the editor instance.\n     * It expects a function that should return a promise or `undefined`.\n     *\n     * ```ts\n     * watchdog.setDestructor( editor => {\n     * \t// Do something before the editor is destroyed.\n     *\n     * \treturn editor\n     * \t\t.destroy()\n     * \t\t.then( () => {\n     * \t\t\t// Do something after the editor is destroyed.\n     * \t\t} );\n     * } );\n     * ```\n     */\n    setDestructor(destructor) {\n        this._destructor = destructor;\n    }\n    /**\n     * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes\n     * the state to `initializing`.\n     *\n     * @fires restart\n     */\n    _restart() {\n        return Promise.resolve()\n            .then(() => {\n            this.state = 'initializing';\n            this._fire('stateChange');\n            return this._destroy();\n        })\n            .catch(err => {\n            console.error('An error happened during the editor destroying.', err);\n        })\n            .then(() => {\n            // Pre-process some data from the original editor config.\n            // Our goal here is to make sure that the restarted editor will be reinitialized with correct set of roots.\n            // We are not interested in any data set in config or in `.create()` first parameter. It will be replaced anyway.\n            // But we need to set them correctly to make sure that proper roots are created.\n            //\n            // Since a different set of roots will be created, `lazyRoots` and `rootsAttributes` properties must be managed too.\n            // Keys are root names, values are ''. Used when the editor was initialized by setting the first parameter to document data.\n            const existingRoots = {};\n            // Keeps lazy roots. They may be different when compared to initial config if some of the roots were loaded.\n            const lazyRoots = [];\n            // Roots attributes from the old config. Will be referred when setting new attributes.\n            const oldRootsAttributes = this._config.rootsAttributes || {};\n            // New attributes to be set. Is filled only for roots that still exist in the document.\n            const rootsAttributes = {};\n            // Traverse through the roots saved when the editor crashed and set up the discussed values.\n            for (const [rootName, rootData] of Object.entries(this._data.roots)) {\n                if (rootData.isLoaded) {\n                    existingRoots[rootName] = '';\n                    rootsAttributes[rootName] = oldRootsAttributes[rootName] || {};\n                }\n                else {\n                    lazyRoots.push(rootName);\n                }\n            }\n            const updatedConfig = {\n                ...this._config,\n                extraPlugins: this._config.extraPlugins || [],\n                lazyRoots,\n                rootsAttributes,\n                _watchdogInitialData: this._data\n            };\n            // Delete `initialData` as it is not needed. Data will be set by the watchdog based on `_watchdogInitialData`.\n            // First parameter of the editor `.create()` will be used to set up initial roots.\n            delete updatedConfig.initialData;\n            updatedConfig.extraPlugins.push(EditorWatchdogInitPlugin);\n            if (this._initUsingData) {\n                return this.create(existingRoots, updatedConfig, updatedConfig.context);\n            }\n            else {\n                // Set correct editables to make sure that proper roots are created and linked with DOM elements.\n                // No need to set initial data, as it would be discarded anyway.\n                //\n                // If one element was initially set in `elementOrData`, then use that original element to restart the editor.\n                // This is for compatibility purposes with single-root editor types.\n                if (isElement(this._elementOrData)) {\n                    return this.create(this._elementOrData, updatedConfig, updatedConfig.context);\n                }\n                else {\n                    return this.create(this._editables, updatedConfig, updatedConfig.context);\n                }\n            }\n        })\n            .then(() => {\n            this._fire('restart');\n        });\n    }\n    /**\n     * Creates the editor instance and keeps it running, using the defined creator and destructor.\n     *\n     * @param elementOrData The editor source element or the editor data.\n     * @param config The editor configuration.\n     * @param context A context for the editor.\n     */\n    create(elementOrData = this._elementOrData, config = this._config, context) {\n        return Promise.resolve()\n            .then(() => {\n            super._startErrorHandling();\n            this._elementOrData = elementOrData;\n            // Use document data in the first parameter of the editor `.create()` call only if it was used like this originally.\n            // Use document data if a string or object with strings was passed.\n            this._initUsingData = typeof elementOrData == 'string' ||\n                (Object.keys(elementOrData).length > 0 && typeof Object.values(elementOrData)[0] == 'string');\n            // Clone configuration because it might be shared within multiple watchdog instances. Otherwise,\n            // when an error occurs in one of these editors, the watchdog will restart all of them.\n            this._config = this._cloneEditorConfiguration(config) || {};\n            this._config.context = context;\n            return this._creator(elementOrData, this._config);\n        })\n            .then(editor => {\n            this._editor = editor;\n            editor.model.document.on('change:data', this._throttledSave);\n            this._lastDocumentVersion = editor.model.document.version;\n            this._data = this._getData();\n            if (!this._initUsingData) {\n                this._editables = this._getEditables();\n            }\n            this.state = 'ready';\n            this._fire('stateChange');\n        });\n    }\n    /**\n     * Destroys the watchdog and the current editor instance. It fires the callback\n     * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.\n     * It also sets the state to `destroyed`.\n     */\n    destroy() {\n        return Promise.resolve()\n            .then(() => {\n            this.state = 'destroyed';\n            this._fire('stateChange');\n            super.destroy();\n            return this._destroy();\n        });\n    }\n    _destroy() {\n        return Promise.resolve()\n            .then(() => {\n            this._stopErrorHandling();\n            this._throttledSave.cancel();\n            const editor = this._editor;\n            this._editor = null;\n            // Remove the `change:data` listener before destroying the editor.\n            // Incorrectly written plugins may trigger firing `change:data` events during the editor destruction phase\n            // causing the watchdog to call `editor.getData()` when some parts of editor are already destroyed.\n            editor.model.document.off('change:data', this._throttledSave);\n            return this._destructor(editor);\n        });\n    }\n    /**\n     * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at\n     * the moment of the crash.\n     */\n    _save() {\n        const version = this._editor.model.document.version;\n        try {\n            this._data = this._getData();\n            if (!this._initUsingData) {\n                this._editables = this._getEditables();\n            }\n            this._lastDocumentVersion = version;\n        }\n        catch (err) {\n            console.error(err, 'An error happened during restoring editor data. ' +\n                'Editor will be restored from the previously saved data.');\n        }\n    }\n    /**\n     * @internal\n     */\n    _setExcludedProperties(props) {\n        this._excludedProps = props;\n    }\n    /**\n     * Gets all data that is required to reinitialize editor instance.\n     */\n    _getData() {\n        const editor = this._editor;\n        const roots = editor.model.document.roots.filter(root => root.isAttached() && root.rootName != '$graveyard');\n        const { plugins } = editor;\n        // `as any` to avoid linking from external private repo.\n        const commentsRepository = plugins.has('CommentsRepository') && plugins.get('CommentsRepository');\n        const trackChanges = plugins.has('TrackChanges') && plugins.get('TrackChanges');\n        const data = {\n            roots: {},\n            markers: {},\n            commentThreads: JSON.stringify([]),\n            suggestions: JSON.stringify([])\n        };\n        roots.forEach(root => {\n            data.roots[root.rootName] = {\n                content: JSON.stringify(Array.from(root.getChildren())),\n                attributes: JSON.stringify(Array.from(root.getAttributes())),\n                isLoaded: root._isLoaded\n            };\n        });\n        for (const marker of editor.model.markers) {\n            if (!marker._affectsData) {\n                continue;\n            }\n            data.markers[marker.name] = {\n                rangeJSON: marker.getRange().toJSON(),\n                usingOperation: marker._managedUsingOperations,\n                affectsData: marker._affectsData\n            };\n        }\n        if (commentsRepository) {\n            data.commentThreads = JSON.stringify(commentsRepository.getCommentThreads({ toJSON: true, skipNotAttached: true }));\n        }\n        if (trackChanges) {\n            data.suggestions = JSON.stringify(trackChanges.getSuggestions({ toJSON: true, skipNotAttached: true }));\n        }\n        return data;\n    }\n    /**\n     * For each attached model root, returns its HTML editable element (if available).\n     */\n    _getEditables() {\n        const editables = {};\n        for (const rootName of this.editor.model.document.getRootNames()) {\n            const editable = this.editor.ui.getEditableElement(rootName);\n            if (editable) {\n                editables[rootName] = editable;\n            }\n        }\n        return editables;\n    }\n    /**\n     * Traverses the error context and the current editor to find out whether these structures are connected\n     * to each other via properties.\n     *\n     * @internal\n     */\n    _isErrorComingFromThisItem(error) {\n        return areConnectedThroughProperties(this._editor, error.context, this._excludedProps);\n    }\n    /**\n     * Clones the editor configuration.\n     */\n    _cloneEditorConfiguration(config) {\n        return cloneDeepWith(config, (value, key) => {\n            // Leave DOM references.\n            if (isElement(value)) {\n                return value;\n            }\n            if (key === 'context') {\n                return value;\n            }\n        });\n    }\n}\n/**\n * Internal plugin that is used to stop the default editor initialization and restoring the editor state\n * based on the `editor.config._watchdogInitialData` data.\n */\nclass EditorWatchdogInitPlugin {\n    constructor(editor) {\n        this.editor = editor;\n        this._data = editor.config.get('_watchdogInitialData');\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        // Stops the default editor initialization and use the saved data to restore the editor state.\n        // Some of data could not be initialize as a config properties. It is important to keep the data\n        // in the same form as it was before the restarting.\n        this.editor.data.on('init', evt => {\n            evt.stop();\n            this.editor.model.enqueueChange({ isUndoable: false }, writer => {\n                this._restoreCollaborationData();\n                this._restoreEditorData(writer);\n            });\n            this.editor.data.fire('ready');\n            // Keep priority `'high' - 1` to be sure that RTC initialization will be first.\n        }, { priority: 1000 - 1 });\n    }\n    /**\n     * Creates a model node (element or text) based on provided JSON.\n     */\n    _createNode(writer, jsonNode) {\n        if ('name' in jsonNode) {\n            // If child has name property, it is an Element.\n            const element = writer.createElement(jsonNode.name, jsonNode.attributes);\n            if (jsonNode.children) {\n                for (const child of jsonNode.children) {\n                    element._appendChild(this._createNode(writer, child));\n                }\n            }\n            return element;\n        }\n        else {\n            // Otherwise, it is a Text node.\n            return writer.createText(jsonNode.data, jsonNode.attributes);\n        }\n    }\n    /**\n     * Restores the editor by setting the document data, roots attributes and markers.\n     */\n    _restoreEditorData(writer) {\n        const editor = this.editor;\n        Object.entries(this._data.roots).forEach(([rootName, { content, attributes }]) => {\n            const parsedNodes = JSON.parse(content);\n            const parsedAttributes = JSON.parse(attributes);\n            const rootElement = editor.model.document.getRoot(rootName);\n            for (const [key, value] of parsedAttributes) {\n                writer.setAttribute(key, value, rootElement);\n            }\n            for (const child of parsedNodes) {\n                const node = this._createNode(writer, child);\n                writer.insert(node, rootElement, 'end');\n            }\n        });\n        Object.entries(this._data.markers).forEach(([markerName, markerOptions]) => {\n            const { document } = editor.model;\n            const { rangeJSON: { start, end }, ...options } = markerOptions;\n            const root = document.getRoot(start.root);\n            const startPosition = writer.createPositionFromPath(root, start.path, start.stickiness);\n            const endPosition = writer.createPositionFromPath(root, end.path, end.stickiness);\n            const range = writer.createRange(startPosition, endPosition);\n            writer.addMarker(markerName, {\n                range,\n                ...options\n            });\n        });\n    }\n    /**\n     * Restores the editor collaboration data - comment threads and suggestions.\n     */\n    _restoreCollaborationData() {\n        // `as any` to avoid linking from external private repo.\n        const parsedCommentThreads = JSON.parse(this._data.commentThreads);\n        const parsedSuggestions = JSON.parse(this._data.suggestions);\n        parsedCommentThreads.forEach(commentThreadData => {\n            const channelId = this.editor.config.get('collaboration.channelId');\n            const commentsRepository = this.editor.plugins.get('CommentsRepository');\n            if (commentsRepository.hasCommentThread(commentThreadData.threadId)) {\n                const commentThread = commentsRepository.getCommentThread(commentThreadData.threadId);\n                commentThread.remove();\n            }\n            commentsRepository.addCommentThread({ channelId, ...commentThreadData });\n        });\n        parsedSuggestions.forEach(suggestionData => {\n            const trackChangesEditing = this.editor.plugins.get('TrackChangesEditing');\n            if (trackChangesEditing.hasSuggestion(suggestionData.id)) {\n                const suggestion = trackChangesEditing.getSuggestion(suggestionData.id);\n                suggestion.attributes = suggestionData.attributes;\n            }\n            else {\n                trackChangesEditing.addSuggestionData(suggestionData);\n            }\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Watchdog from './watchdog';\nimport EditorWatchdog from './editorwatchdog';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties';\nimport getSubNodes from './utils/getsubnodes';\nconst mainQueueId = Symbol('MainQueueId');\n/**\n * A watchdog for the {@link module:core/context~Context} class.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\nexport default class ContextWatchdog extends Watchdog {\n    /**\n     * The context watchdog class constructor.\n     *\n     * ```ts\n     * const watchdog = new ContextWatchdog( Context );\n     *\n     * await watchdog.create( contextConfiguration );\n     *\n     * await watchdog.add( item );\n     * ```\n     *\n     * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.\n     *\n     * @param Context The {@link module:core/context~Context} class.\n     * @param watchdogConfig The watchdog configuration.\n     */\n    constructor(Context, watchdogConfig = {}) {\n        super(watchdogConfig);\n        /**\n         * A map of internal watchdogs for added items.\n         */\n        this._watchdogs = new Map();\n        /**\n         * The current context instance.\n         */\n        this._context = null;\n        /**\n         * Context properties (nodes/references) that are gathered during the initial context creation\n         * and are used to distinguish the origin of an error.\n         */\n        this._contextProps = new Set();\n        /**\n         * An action queue, which is used to handle async functions queuing.\n         */\n        this._actionQueues = new ActionQueues();\n        this._watchdogConfig = watchdogConfig;\n        // Default creator and destructor.\n        this._creator = contextConfig => Context.create(contextConfig);\n        this._destructor = context => context.destroy();\n        this._actionQueues.onEmpty(() => {\n            if (this.state === 'initializing') {\n                this.state = 'ready';\n                this._fire('stateChange');\n            }\n        });\n    }\n    /**\n     * Sets the function that is responsible for the context creation.\n     * It expects a function that should return a promise (or `undefined`).\n     *\n     * ```ts\n     * watchdog.setCreator( config => Context.create( config ) );\n     * ```\n     */\n    setCreator(creator) {\n        this._creator = creator;\n    }\n    /**\n     * Sets the function that is responsible for the context destruction.\n     * Overrides the default destruction function, which destroys only the context instance.\n     * It expects a function that should return a promise (or `undefined`).\n     *\n     * ```ts\n     * watchdog.setDestructor( context => {\n     * \t// Do something before the context is destroyed.\n     *\n     * \treturn context\n     * \t\t.destroy()\n     * \t\t.then( () => {\n     * \t\t\t// Do something after the context is destroyed.\n     * \t\t} );\n     * } );\n     * ```\n     */\n    setDestructor(destructor) {\n        this._destructor = destructor;\n    }\n    /**\n     * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,\n     * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.\n     */\n    get context() {\n        return this._context;\n    }\n    /**\n     * Initializes the context watchdog. Once it is created, the watchdog takes care about\n     * recreating the context and the provided items, and starts the error handling mechanism.\n     *\n     * ```ts\n     * await watchdog.create( {\n     * \tplugins: []\n     * } );\n     * ```\n     *\n     * @param contextConfig The context configuration. See {@link module:core/context~Context}.\n     */\n    create(contextConfig = {}) {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this._contextConfig = contextConfig;\n            return this._create();\n        });\n    }\n    /**\n     * Returns an item instance with the given `itemId`.\n     *\n     * ```ts\n     * const editor1 = watchdog.getItem( 'editor1' );\n     * ```\n     *\n     * @param itemId The item ID.\n     * @returns The item instance or `undefined` if an item with a given ID has not been found.\n     */\n    getItem(itemId) {\n        const watchdog = this._getWatchdog(itemId);\n        return watchdog._item;\n    }\n    /**\n     * Gets the state of the given item. See {@link #state} for a list of available states.\n     *\n     * ```ts\n     * const editor1State = watchdog.getItemState( 'editor1' );\n     * ```\n     *\n     * @param itemId Item ID.\n     * @returns The state of the item.\n     */\n    getItemState(itemId) {\n        const watchdog = this._getWatchdog(itemId);\n        return watchdog.state;\n    }\n    /**\n     * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.\n     *\n     * Items can be passed together as an array of objects:\n     *\n     * ```ts\n     * await watchdog.add( [ {\n     * \tid: 'editor1',\n     * \ttype: 'editor',\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\n     * \tconfig: {\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n     * \t},\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n     * } ] );\n     * ```\n     *\n     * Or one by one as objects:\n     *\n     * ```ts\n     * await watchdog.add( {\n     * \tid: 'editor1',\n     * \ttype: 'editor',\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\n     * \tconfig: {\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n     * \t},\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n     * ] );\n     * ```\n     *\n     * Then an instance can be retrieved using the {@link #getItem} method:\n     *\n     * ```ts\n     * const editor1 = watchdog.getItem( 'editor1' );\n     * ```\n     *\n     * Note that this method can be called multiple times, but for performance reasons it is better\n     * to pass all items together.\n     *\n     * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.\n     */\n    add(itemConfigurationOrItemConfigurations) {\n        const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);\n        return Promise.all(itemConfigurations.map(item => {\n            return this._actionQueues.enqueue(item.id, () => {\n                if (this.state === 'destroyed') {\n                    throw new Error('Cannot add items to destroyed watchdog.');\n                }\n                if (!this._context) {\n                    throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');\n                }\n                let watchdog;\n                if (this._watchdogs.has(item.id)) {\n                    throw new Error(`Item with the given id is already added: '${item.id}'.`);\n                }\n                if (item.type === 'editor') {\n                    watchdog = new EditorWatchdog(null, this._watchdogConfig);\n                    watchdog.setCreator(item.creator);\n                    watchdog._setExcludedProperties(this._contextProps);\n                    if (item.destructor) {\n                        watchdog.setDestructor(item.destructor);\n                    }\n                    this._watchdogs.set(item.id, watchdog);\n                    // Enqueue the internal watchdog errors within the main queue.\n                    // And propagate the internal `error` events as `itemError` event.\n                    watchdog.on('error', (evt, { error, causesRestart }) => {\n                        this._fire('itemError', { itemId: item.id, error });\n                        // Do not enqueue the item restart action if the item will not restart.\n                        if (!causesRestart) {\n                            return;\n                        }\n                        this._actionQueues.enqueue(item.id, () => new Promise(res => {\n                            const rethrowRestartEventOnce = () => {\n                                watchdog.off('restart', rethrowRestartEventOnce);\n                                this._fire('itemRestart', { itemId: item.id });\n                                res();\n                            };\n                            watchdog.on('restart', rethrowRestartEventOnce);\n                        }));\n                    });\n                    return watchdog.create(item.sourceElementOrData, item.config, this._context);\n                }\n                else {\n                    throw new Error(`Not supported item type: '${item.type}'.`);\n                }\n            });\n        }));\n    }\n    /**\n     * Removes and destroys item(s) with given ID(s).\n     *\n     * ```ts\n     * await watchdog.remove( 'editor1' );\n     * ```\n     *\n     * Or\n     *\n     * ```ts\n     * await watchdog.remove( [ 'editor1', 'editor2' ] );\n     * ```\n     *\n     * @param itemIdOrItemIds Item ID or an array of item IDs.\n     */\n    remove(itemIdOrItemIds) {\n        const itemIds = toArray(itemIdOrItemIds);\n        return Promise.all(itemIds.map(itemId => {\n            return this._actionQueues.enqueue(itemId, () => {\n                const watchdog = this._getWatchdog(itemId);\n                this._watchdogs.delete(itemId);\n                return watchdog.destroy();\n            });\n        }));\n    }\n    /**\n     * Destroys the context watchdog and all added items.\n     * Once the context watchdog is destroyed, new items cannot be added.\n     *\n     * ```ts\n     * await watchdog.destroy();\n     * ```\n     */\n    destroy() {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this.state = 'destroyed';\n            this._fire('stateChange');\n            super.destroy();\n            return this._destroy();\n        });\n    }\n    /**\n     * Restarts the context watchdog.\n     */\n    _restart() {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this.state = 'initializing';\n            this._fire('stateChange');\n            return this._destroy()\n                .catch(err => {\n                console.error('An error happened during destroying the context or items.', err);\n            })\n                .then(() => this._create())\n                .then(() => this._fire('restart'));\n        });\n    }\n    /**\n     * Initializes the context watchdog.\n     */\n    _create() {\n        return Promise.resolve()\n            .then(() => {\n            this._startErrorHandling();\n            return this._creator(this._contextConfig);\n        })\n            .then(context => {\n            this._context = context;\n            this._contextProps = getSubNodes(this._context);\n            return Promise.all(Array.from(this._watchdogs.values())\n                .map(watchdog => {\n                watchdog._setExcludedProperties(this._contextProps);\n                return watchdog.create(undefined, undefined, this._context);\n            }));\n        });\n    }\n    /**\n     * Destroys the context instance and all added items.\n     */\n    _destroy() {\n        return Promise.resolve()\n            .then(() => {\n            this._stopErrorHandling();\n            const context = this._context;\n            this._context = null;\n            this._contextProps = new Set();\n            return Promise.all(Array.from(this._watchdogs.values())\n                .map(watchdog => watchdog.destroy()))\n                // Context destructor destroys each editor.\n                .then(() => this._destructor(context));\n        });\n    }\n    /**\n     * Returns the watchdog for a given item ID.\n     *\n     * @param itemId Item ID.\n     */\n    _getWatchdog(itemId) {\n        const watchdog = this._watchdogs.get(itemId);\n        if (!watchdog) {\n            throw new Error(`Item with the given id was not registered: ${itemId}.`);\n        }\n        return watchdog;\n    }\n    /**\n     * Checks whether an error comes from the context instance and not from the item instances.\n     *\n     * @internal\n     */\n    _isErrorComingFromThisItem(error) {\n        for (const watchdog of this._watchdogs.values()) {\n            if (watchdog._isErrorComingFromThisItem(error)) {\n                return false;\n            }\n        }\n        return areConnectedThroughProperties(this._context, error.context);\n    }\n}\n/**\n * Manager of action queues that allows queuing async functions.\n */\nclass ActionQueues {\n    constructor() {\n        this._onEmptyCallbacks = [];\n        this._queues = new Map();\n        this._activeActions = 0;\n    }\n    /**\n     * Used to register callbacks that will be run when the queue becomes empty.\n     *\n     * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.\n     */\n    onEmpty(onEmptyCallback) {\n        this._onEmptyCallbacks.push(onEmptyCallback);\n    }\n    /**\n     * It adds asynchronous actions (functions) to the proper queue and runs them one by one.\n     *\n     * @param queueId The action queue ID.\n     * @param action A function that should be enqueued.\n     */\n    enqueue(queueId, action) {\n        const isMainAction = queueId === mainQueueId;\n        this._activeActions++;\n        if (!this._queues.get(queueId)) {\n            this._queues.set(queueId, Promise.resolve());\n        }\n        // List all sources of actions that the current action needs to await for.\n        // For the main action wait for all other actions.\n        // For the item action wait only for the item queue and the main queue.\n        const awaitedActions = isMainAction ?\n            Promise.all(this._queues.values()) :\n            Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);\n        const queueWithAction = awaitedActions.then(action);\n        // Catch all errors in the main queue to stack promises even if an error occurred in the past.\n        const nonErrorQueue = queueWithAction.catch(() => { });\n        this._queues.set(queueId, nonErrorQueue);\n        return queueWithAction.finally(() => {\n            this._activeActions--;\n            if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {\n                this._onEmptyCallbacks.forEach(cb => cb());\n            }\n        });\n    }\n}\n/**\n * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.\n *\n * @param elementOrArray The value to transform to an array.\n * @returns An array created from data.\n */\nfunction toArray(elementOrArray) {\n    return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];\n}\n", "import * as i0 from '@angular/core';\nimport { EventEmitter, forwardRef, Component, Input, Output, NgModule } from '@angular/core';\nimport { EditorWatchdog } from '@ckeditor/ckeditor5-watchdog';\nimport { first } from 'rxjs/operators';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n// A copy of @ckeditor/ckeditor5-utils/src/uid.js\n// A hash table of hex numbers to avoid using toString() in uid() which is costly.\n// [ '00', '01', '02', ..., 'fe', 'ff' ]\nfunction CKEditorComponent_ng_template_0_Template(rf, ctx) {}\nconst HEX_NUMBERS = new Array(256).fill(0).map((val, index) => ('0' + index.toString(16)).slice(-2));\n/**\n * Returns a unique id. The id starts with an \"e\" character and a randomly generated string of\n * 32 alphanumeric characters.\n *\n * **Note**: The characters the unique id is built from correspond to the hex number notation\n * (from \"0\" to \"9\", from \"a\" to \"f\"). In other words, each id corresponds to an \"e\" followed\n * by 16 8-bit numbers next to each other.\n *\n * @returns An unique id string.\n */\nfunction uid() {\n  // Let's create some positive random 32bit integers first.\n  //\n  // 1. Math.random() is a float between 0 and 1.\n  // 2. 0x100000000 is 2^32 = 4294967296.\n  // 3. >>> 0 enforces integer (in JS all numbers are floating point).\n  //\n  // For instance:\n  //\t\tMath.random() * 0x100000000 = 3366450031.853859\n  // but\n  //\t\tMath.random() * 0x100000000 >>> 0 = 3366450031.\n  const r1 = Math.random() * 0x100000000 >>> 0;\n  const r2 = Math.random() * 0x100000000 >>> 0;\n  const r3 = Math.random() * 0x100000000 >>> 0;\n  const r4 = Math.random() * 0x100000000 >>> 0;\n  // Make sure that id does not start with number.\n  return 'e' + HEX_NUMBERS[r1 >> 0 & 0xFF] + HEX_NUMBERS[r1 >> 8 & 0xFF] + HEX_NUMBERS[r1 >> 16 & 0xFF] + HEX_NUMBERS[r1 >> 24 & 0xFF] + HEX_NUMBERS[r2 >> 0 & 0xFF] + HEX_NUMBERS[r2 >> 8 & 0xFF] + HEX_NUMBERS[r2 >> 16 & 0xFF] + HEX_NUMBERS[r2 >> 24 & 0xFF] + HEX_NUMBERS[r3 >> 0 & 0xFF] + HEX_NUMBERS[r3 >> 8 & 0xFF] + HEX_NUMBERS[r3 >> 16 & 0xFF] + HEX_NUMBERS[r3 >> 24 & 0xFF] + HEX_NUMBERS[r4 >> 0 & 0xFF] + HEX_NUMBERS[r4 >> 8 & 0xFF] + HEX_NUMBERS[r4 >> 16 & 0xFF] + HEX_NUMBERS[r4 >> 24 & 0xFF];\n}\nconst ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from Angular integration (@ckeditor/ckeditor5-angular)';\nclass CKEditorComponent {\n  constructor(elementRef, ngZone) {\n    /**\n     * The configuration of the editor.\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editorconfig-EditorConfig.html\n     * to learn more.\n     */\n    this.config = {};\n    /**\n     * The initial data of the editor. Useful when not using the ngModel.\n     * See https://angular.io/api/forms/NgModel to learn more.\n     */\n    this.data = '';\n    /**\n     * Tag name of the editor component.\n     *\n     * The default tag is 'div'.\n     */\n    this.tagName = 'div';\n    /**\n     * Allows disabling the two-way data binding mechanism. Disabling it can boost performance for large documents.\n     *\n     * When a component is connected using the [(ngModel)] or [formControl] directives and this value is set to true then none of the data\n     * will ever be synchronized.\n     *\n     * An integrator must call `editor.data.get()` manually once the application needs the editor's data.\n     * An editor instance can be received in the `ready()` callback.\n     */\n    this.disableTwoWayDataBinding = false;\n    /**\n     * Fires when the editor is ready. It corresponds with the `editor#ready`\n     * https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html#event-ready\n     * event.\n     */\n    this.ready = new EventEmitter();\n    /**\n     * Fires when the content of the editor has changed. It corresponds with the `editor.model.document#change`\n     * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_model_document-Document.html#event-change\n     * event.\n     */\n    this.change = new EventEmitter();\n    /**\n     * Fires when the editing view of the editor is blurred. It corresponds with the `editor.editing.view.document#blur`\n     * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:blur\n     * event.\n     */\n    this.blur = new EventEmitter();\n    /**\n     * Fires when the editing view of the editor is focused. It corresponds with the `editor.editing.view.document#focus`\n     * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:focus\n     * event.\n     */\n    this.focus = new EventEmitter();\n    /**\n     * Fires when the editor component crashes.\n     */\n    this.error = new EventEmitter();\n    /**\n     * If the component is read–only before the editor instance is created, it remembers that state,\n     * so the editor can become read–only once it is ready.\n     */\n    this.initiallyDisabled = false;\n    /**\n     * A lock flag preventing from calling the `cvaOnChange()` during setting editor data.\n     */\n    this.isEditorSettingData = false;\n    this.id = uid();\n    this.ngZone = ngZone;\n    this.elementRef = elementRef;\n    // To avoid issues with the community typings and CKEditor 5, let's treat window as any. See #342.\n    const {\n      CKEDITOR_VERSION\n    } = window;\n    if (CKEDITOR_VERSION) {\n      const [major] = CKEDITOR_VERSION.split('.').map(Number);\n      if (major < 37) {\n        console.warn('The <CKEditor> component requires using CKEditor 5 in version 37 or higher.');\n      }\n    } else {\n      console.warn('Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.');\n    }\n  }\n  /**\n   * When set `true`, the editor becomes read-only.\n   * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html#member-isReadOnly\n   * to learn more.\n   */\n  set disabled(isDisabled) {\n    this.setDisabledState(isDisabled);\n  }\n  get disabled() {\n    if (this.editorInstance) {\n      return this.editorInstance.isReadOnly;\n    }\n    return this.initiallyDisabled;\n  }\n  /**\n   * The instance of the editor created by this component.\n   */\n  get editorInstance() {\n    let editorWatchdog = this.editorWatchdog;\n    if (this.watchdog) {\n      // Temporarily use the `_watchdogs` internal map as the `getItem()` method throws\n      // an error when the item is not registered yet.\n      // See https://github.com/ckeditor/ckeditor5-angular/issues/177.\n      // TODO should be able to change when new chages in Watcdog are released.\n      editorWatchdog = this.watchdog._watchdogs.get(this.id);\n    }\n    if (editorWatchdog) {\n      return editorWatchdog.editor;\n    }\n    return null;\n  }\n  getId() {\n    return this.id;\n  }\n  // Implementing the OnChanges interface. Whenever the `data` property is changed, update the editor content.\n  ngOnChanges(changes) {\n    if (Object.prototype.hasOwnProperty.call(changes, 'data') && changes.data && !changes.data.isFirstChange()) {\n      this.writeValue(changes.data.currentValue);\n    }\n  }\n  // Implementing the AfterViewInit interface.\n  ngAfterViewInit() {\n    this.attachToWatchdog();\n  }\n  // Implementing the OnDestroy interface.\n  async ngOnDestroy() {\n    if (this.watchdog) {\n      await this.watchdog.remove(this.id);\n    } else if (this.editorWatchdog && this.editorWatchdog.editor) {\n      await this.editorWatchdog.destroy();\n      this.editorWatchdog = undefined;\n    }\n  }\n  // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n  writeValue(value) {\n    // This method is called with the `null` value when the form resets.\n    // A component's responsibility is to restore to the initial state.\n    if (value === null) {\n      value = '';\n    }\n    // If already initialized.\n    if (this.editorInstance) {\n      // The lock mechanism prevents from calling `cvaOnChange()` during changing\n      // the editor state. See #139\n      this.isEditorSettingData = true;\n      this.editorInstance.data.set(value);\n      this.isEditorSettingData = false;\n    }\n    // If not, wait for it to be ready; store the data.\n    else {\n      // If the editor element is already available, then update its content.\n      this.data = value;\n      // If not, then wait until it is ready\n      // and change data only for the first `ready` event.\n      this.ready.pipe(first()).subscribe(editor => {\n        editor.data.set(this.data);\n      });\n    }\n  }\n  // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n  registerOnChange(callback) {\n    this.cvaOnChange = callback;\n  }\n  // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n  registerOnTouched(callback) {\n    this.cvaOnTouched = callback;\n  }\n  // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n  setDisabledState(isDisabled) {\n    // If already initialized.\n    if (this.editorInstance) {\n      if (isDisabled) {\n        this.editorInstance.enableReadOnlyMode(ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID);\n      } else {\n        this.editorInstance.disableReadOnlyMode(ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID);\n      }\n    }\n    // Store the state anyway to use it once the editor is created.\n    this.initiallyDisabled = isDisabled;\n  }\n  /**\n   * Creates the editor instance, sets initial editor data, then integrates\n   * the editor with the Angular component. This method does not use the `editor.data.set()`\n   * because of the issue in the collaboration mode (#6).\n   */\n  attachToWatchdog() {\n    // TODO: elementOrData parameter type can be simplified to HTMLElemen after templated Watchdog will be released.\n    const creator = (elementOrData, config) => {\n      return this.ngZone.runOutsideAngular(async () => {\n        this.elementRef.nativeElement.appendChild(elementOrData);\n        const editor = await this.editor.create(elementOrData, config);\n        if (this.initiallyDisabled) {\n          editor.enableReadOnlyMode(ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID);\n        }\n        this.ngZone.run(() => {\n          this.ready.emit(editor);\n        });\n        this.setUpEditorEvents(editor);\n        return editor;\n      });\n    };\n    const destructor = async editor => {\n      await editor.destroy();\n      this.elementRef.nativeElement.removeChild(this.editorElement);\n    };\n    const emitError = e => {\n      // Do not run change detection by re-entering the Angular zone if the `error`\n      // emitter doesn't have any subscribers.\n      // Subscribers are pushed onto the list whenever `error` is listened inside the template:\n      // `<ckeditor (error)=\"onError(...)\"></ckeditor>`.\n      if (hasObservers(this.error)) {\n        this.ngZone.run(() => this.error.emit(e));\n      }\n    };\n    const element = document.createElement(this.tagName);\n    const config = this.getConfig();\n    this.editorElement = element;\n    // Based on the presence of the watchdog decide how to initialize the editor.\n    if (this.watchdog) {\n      // When the context watchdog is passed add the new item to it based on the passed configuration.\n      this.watchdog.add({\n        id: this.id,\n        type: 'editor',\n        creator,\n        destructor,\n        sourceElementOrData: element,\n        config\n      }).catch(e => {\n        emitError(e);\n      });\n      this.watchdog.on('itemError', (_, {\n        itemId\n      }) => {\n        if (itemId === this.id) {\n          emitError();\n        }\n      });\n    } else {\n      // In the other case create the watchdog by hand to keep the editor running.\n      const editorWatchdog = new EditorWatchdog(this.editor, this.editorWatchdogConfig);\n      editorWatchdog.setCreator(creator);\n      editorWatchdog.setDestructor(destructor);\n      editorWatchdog.on('error', emitError);\n      this.editorWatchdog = editorWatchdog;\n      this.ngZone.runOutsideAngular(() => {\n        // Note: must be called outside of the Angular zone too because `create` is calling\n        // `_startErrorHandling` within a microtask which sets up `error` listener on the window.\n        editorWatchdog.create(element, config).catch(e => {\n          emitError(e);\n        });\n      });\n    }\n  }\n  getConfig() {\n    if (this.data && this.config.initialData) {\n      throw new Error('Editor data should be provided either using `config.initialData` or `data` properties.');\n    }\n    const config = {\n      ...this.config\n    };\n    // Merge two possible ways of providing data into the `config.initialData` field.\n    const initialData = this.config.initialData || this.data;\n    if (initialData) {\n      // Define the `config.initialData` only when the initial content is specified.\n      config.initialData = initialData;\n    }\n    return config;\n  }\n  /**\n   * Integrates the editor with the component by attaching related event listeners.\n   */\n  setUpEditorEvents(editor) {\n    const modelDocument = editor.model.document;\n    const viewDocument = editor.editing.view.document;\n    modelDocument.on('change:data', evt => {\n      this.ngZone.run(() => {\n        if (this.disableTwoWayDataBinding) {\n          return;\n        }\n        if (this.cvaOnChange && !this.isEditorSettingData) {\n          const data = editor.data.get();\n          this.cvaOnChange(data);\n        }\n        this.change.emit({\n          event: evt,\n          editor\n        });\n      });\n    });\n    viewDocument.on('focus', evt => {\n      this.ngZone.run(() => {\n        this.focus.emit({\n          event: evt,\n          editor\n        });\n      });\n    });\n    viewDocument.on('blur', evt => {\n      this.ngZone.run(() => {\n        if (this.cvaOnTouched) {\n          this.cvaOnTouched();\n        }\n        this.blur.emit({\n          event: evt,\n          editor\n        });\n      });\n    });\n  }\n}\nCKEditorComponent.ɵfac = function CKEditorComponent_Factory(t) {\n  return new (t || CKEditorComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n};\nCKEditorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: CKEditorComponent,\n  selectors: [[\"ckeditor\"]],\n  inputs: {\n    editor: \"editor\",\n    config: \"config\",\n    data: \"data\",\n    tagName: \"tagName\",\n    watchdog: \"watchdog\",\n    editorWatchdogConfig: \"editorWatchdogConfig\",\n    disableTwoWayDataBinding: \"disableTwoWayDataBinding\",\n    disabled: \"disabled\"\n  },\n  outputs: {\n    ready: \"ready\",\n    change: \"change\",\n    blur: \"blur\",\n    focus: \"focus\",\n    error: \"error\"\n  },\n  features: [i0.ɵɵProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    useExisting: forwardRef(() => CKEditorComponent),\n    multi: true\n  }]), i0.ɵɵNgOnChangesFeature],\n  decls: 1,\n  vars: 0,\n  template: function CKEditorComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵtemplate(0, CKEditorComponent_ng_template_0_Template, 0, 0, \"ng-template\");\n    }\n  },\n  encapsulation: 2\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CKEditorComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ckeditor',\n      template: '<ng-template></ng-template>',\n      // Integration with @angular/forms.\n      providers: [{\n        provide: NG_VALUE_ACCESSOR,\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        useExisting: forwardRef(() => CKEditorComponent),\n        multi: true\n      }]\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    editor: [{\n      type: Input\n    }],\n    config: [{\n      type: Input\n    }],\n    data: [{\n      type: Input\n    }],\n    tagName: [{\n      type: Input\n    }],\n    watchdog: [{\n      type: Input\n    }],\n    editorWatchdogConfig: [{\n      type: Input\n    }],\n    disableTwoWayDataBinding: [{\n      type: Input\n    }],\n    disabled: [{\n      type: Input\n    }],\n    ready: [{\n      type: Output\n    }],\n    change: [{\n      type: Output\n    }],\n    blur: [{\n      type: Output\n    }],\n    focus: [{\n      type: Output\n    }],\n    error: [{\n      type: Output\n    }]\n  });\n})();\nfunction hasObservers(emitter) {\n  // Cast to `any` because `observed` property is available in RxJS >= 7.2.0.\n  // Fallback to checking `observers` list if this property is not defined.\n  return emitter.observed || emitter.observers.length > 0;\n}\n\n/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nclass CKEditorModule {}\nCKEditorModule.ɵfac = function CKEditorModule_Factory(t) {\n  return new (t || CKEditorModule)();\n};\nCKEditorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: CKEditorModule,\n  declarations: [CKEditorComponent],\n  imports: [FormsModule, CommonModule],\n  exports: [CKEditorComponent]\n});\nCKEditorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[FormsModule, CommonModule]]\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CKEditorModule, [{\n    type: NgModule,\n    args: [{\n      imports: [FormsModule, CommonModule],\n      declarations: [CKEditorComponent],\n      exports: [CKEditorComponent]\n    }]\n  }], null, null);\n})();\n\n/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CKEditorComponent, CKEditorModule };\n"],
  "mappings": "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",
  "names": ["document", "config"]
}
