{
  "version": 3,
  "sources": ["../../../../../node_modules/@nicky-lenaers/ngx-scroll-to/fesm2020/nicky-lenaers-ngx-scroll-to.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { ElementRef, PLATFORM_ID, Injectable, Inject, Directive, Input, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { ReplaySubject, throwError } from 'rxjs';\n\n/** Default values for Component Input */\nconst DEFAULTS = {\n  target: null,\n  action: 'click',\n  duration: 650,\n  easing: 'easeInOutQuad',\n  offset: 0,\n  offsetMap: new Map()\n};\n/** Easing Colleciton */\nconst EASING = {\n  easeInQuad: time => {\n    return time * time;\n  },\n  easeOutQuad: time => {\n    return time * (2 - time);\n  },\n  easeInOutQuad: time => {\n    return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time;\n  },\n  easeInCubic: time => {\n    return time * time * time;\n  },\n  easeOutCubic: time => {\n    return --time * time * time + 1;\n  },\n  easeInOutCubic: time => {\n    return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n  },\n  easeInQuart: time => {\n    return time * time * time * time;\n  },\n  easeOutQuart: time => {\n    return 1 - --time * time * time * time;\n  },\n  easeInOutQuart: time => {\n    return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * --time * time * time * time;\n  },\n  easeInQuint: time => {\n    return time * time * time * time * time;\n  },\n  easeOutQuint: time => {\n    return 1 + --time * time * time * time * time;\n  },\n  easeInOutQuint: time => {\n    return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * --time * time * time * time * time;\n  },\n  easeOutElastic: time => {\n    return Math.pow(2, -10 * time) * Math.sin((time - 1 / 4) * (2 * Math.PI) / 1) + 1;\n  }\n};\n/**\n * Set of allowed events as triggers\n * for the Animation to start.\n */\nconst EVENTS = ['click', 'mouseenter', 'mouseover', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'wheel', 'mouseleave', 'mouseout'];\n/**\n * Strip hash (#) from value.\n *\n * @param value \t\t\t\tThe given string value\n * @returns \t\t\t\t\tThe stripped string value\n */\nfunction stripHash(value) {\n  return value.substring(0, 1) === '#' ? value.substring(1) : value;\n}\n/**\n * Test if a given value is a string.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns \t\t\t\t\t\tWhether the given value is a string\n */\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n/**\n * Test if a given Element is the Window.\n *\n * @param container \t\t\t\tThe given Element\n * @returns \t\t\t\t\t\tWhether the given Element is Window\n */\nfunction isWindow(container) {\n  return container === window;\n}\n/**\n * Test if a given value is of type ElementRef.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns               Whether the given value is a number\n */\nfunction isElementRef(value) {\n  return value instanceof ElementRef;\n}\n/**\n * Whether or not the given value is a Native Element.\n *\n * @param value           The given value\n * @returns               Whether or not the value is a Native Element\n */\nfunction isNativeElement(value) {\n  return value instanceof HTMLElement;\n}\n/**\n * Test if a given value is type number.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns \t\t\t\t\t\tWhether the given value is a number\n */\nfunction isNumber(value) {\n  return !isNaN(parseFloat(value)) && isFinite(value);\n}\n\n/** Scroll To Animation */\nclass ScrollToAnimation {\n  /**\n   * Class Constructor.\n   *\n   * @param container            The Container\n   * @param listenerTarget       The Element that listens for DOM Events\n   * @param isWindow             Whether or not the listener is the Window\n   * @param to                   Position to scroll to\n   * @param options              Additional options for scrolling\n   * @param isBrowser            Whether or not execution runs in the browser\n   *                              (as opposed to the server)\n   */\n  constructor(container, listenerTarget, isWindow, to, options, isBrowser) {\n    this.container = container;\n    this.listenerTarget = listenerTarget;\n    this.isWindow = isWindow;\n    this.to = to;\n    this.options = options;\n    this.isBrowser = isBrowser;\n    /** Recursively loop over the Scroll Animation */\n    this.loop = () => {\n      this.timeLapsed += this.tick;\n      this.percentage = this.timeLapsed / this.options.duration;\n      this.percentage = this.percentage > 1 ? 1 : this.percentage;\n      // Position Update\n      this.position = this.startPosition + (this.startPosition - this.to <= 0 ? 1 : -1) * this.distance * EASING[this.options.easing](this.percentage);\n      if (this.lastPosition !== null && this.position === this.lastPosition) {\n        this.stop();\n      } else {\n        this.source$.next(this.position);\n        this.isWindow ? this.listenerTarget.scrollTo(0, Math.floor(this.position)) : this.container.scrollTop = Math.floor(this.position);\n        this.lastPosition = this.position;\n      }\n    };\n    this.tick = 16;\n    this.interval = null;\n    this.lastPosition = null;\n    this.timeLapsed = 0;\n    this.windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n    if (!this.container) {\n      this.startPosition = this.windowScrollTop;\n    } else {\n      this.startPosition = this.isWindow ? this.windowScrollTop : this.container.scrollTop;\n    }\n    // Correction for Starting Position of nested HTML Elements\n    if (this.container && !this.isWindow) {\n      this.to = this.to - this.container.getBoundingClientRect().top + this.startPosition;\n    }\n    // Set Distance\n    const directionalDistance = this.startPosition - this.to;\n    this.distance = this.container ? Math.abs(this.startPosition - this.to) : this.to;\n    this.mappedOffset = this.options.offset;\n    // Set offset from Offset Map\n    if (this.isBrowser) {\n      this.options.offsetMap.forEach((value, key) => this.mappedOffset = window.innerWidth > key ? value : this.mappedOffset);\n    }\n    this.distance += this.mappedOffset * (directionalDistance <= 0 ? 1 : -1);\n    this.source$ = new ReplaySubject();\n  }\n  /**\n   * Start the new Scroll Animation.\n   *\n   * @returns         Observable containing a number\n   */\n  start() {\n    clearInterval(this.interval);\n    this.interval = setInterval(this.loop, this.tick);\n    return this.source$.asObservable();\n  }\n  /**\n   * Stop the current Scroll Animation Loop.\n   *\n   * @param force          Force to stop the Animation Loop\n   * @returns               Void\n   */\n  stop() {\n    clearInterval(this.interval);\n    this.interval = null;\n    this.source$.complete();\n  }\n}\n\n/**\n * The Scroll To Service handles starting, interrupting\n * and ending the actual Scroll Animation. It provides\n * some utilities to find the proper HTML Element on a\n * given page to setup Event Listeners and calculate\n * distances for the Animation.\n */\nclass ScrollToService {\n  /**\n   * Construct and setup required paratemeters.\n   *\n   * @param document         A Reference to the Document\n   * @param platformId       Angular Platform ID\n   */\n  constructor(document, platformId) {\n    this.document = document;\n    this.platformId = platformId;\n    this.interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];\n  }\n  /**\n   * Target an Element to scroll to. Notice that the `TimeOut` decorator\n   * ensures the executing to take place in the next Angular lifecycle.\n   * This allows for scrolling to elements that are e.g. initially hidden\n   * by means of `*ngIf`, but ought to be scrolled to eventually.\n   *\n   * @todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:\n   *  - https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481\n   *\n   * @param options         Configuration Object\n   * @returns               Observable\n   */\n  scrollTo(options) {\n    if (!isPlatformBrowser(this.platformId)) {\n      return new ReplaySubject().asObservable();\n    }\n    return this.start(options);\n  }\n  /**\n   * Start a new Animation.\n   *\n   * @todo Emit proper events from subscription\n   *\n   * @param options         Configuration Object\n   * @returns               Observable\n   */\n  start(options) {\n    // Merge config with default values\n    const mergedConfigOptions = {\n      ...DEFAULTS,\n      ...options\n    };\n    if (this.animation) {\n      this.animation.stop();\n    }\n    const targetNode = this.getNode(mergedConfigOptions.target);\n    if (mergedConfigOptions.target && !targetNode) {\n      return throwError(() => new Error('Unable to find Target Element'));\n    }\n    const container = this.getContainer(mergedConfigOptions, targetNode);\n    if (mergedConfigOptions.container && !container) {\n      return throwError(() => new Error('Unable to find Container Element'));\n    }\n    const listenerTarget = this.getListenerTarget(container) || window;\n    let to = container ? container.getBoundingClientRect().top : 0;\n    if (targetNode) {\n      to = isWindow(listenerTarget) ? window.scrollY + targetNode.getBoundingClientRect().top : targetNode.getBoundingClientRect().top;\n    }\n    // Create Animation\n    this.animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, isPlatformBrowser(this.platformId));\n    const onInterrupt = () => this.animation.stop();\n    this.addInterruptiveEventListeners(listenerTarget, onInterrupt);\n    // Start Animation\n    const animation$ = this.animation.start();\n    this.subscribeToAnimation(animation$, listenerTarget, onInterrupt);\n    return animation$;\n  }\n  /**\n   * Subscribe to the events emitted from the Scrolling\n   * Animation. Events might be used for e.g. unsubscribing\n   * once finished.\n   *\n   * @param animation$              The Animation Observable\n   * @param listenerTarget          The Listener Target for events\n   * @param onInterrupt             The handler for Interruptive Events\n   * @returns                       Void\n   */\n  subscribeToAnimation(animation$, listenerTarget, onInterrupt) {\n    const subscription = animation$.subscribe({\n      complete: () => {\n        this.removeInterruptiveEventListeners(this.interruptiveEvents, listenerTarget, onInterrupt);\n        subscription.unsubscribe();\n      }\n    });\n  }\n  /**\n   * Get the container HTML Element in which\n   * the scrolling should happen.\n   *\n   * @param options         The Merged Configuration Object\n   * @param targetNode    the targeted HTMLElement\n   */\n  getContainer(options, targetNode) {\n    let container = null;\n    if (options.container) {\n      container = this.getNode(options.container, true);\n    } else if (targetNode) {\n      container = this.getFirstScrollableParent(targetNode);\n    }\n    return container;\n  }\n  /**\n   * Add listeners for the Animation Interruptive Events\n   * to the Listener Target.\n   *\n   * @param events            List of events to listen to\n   * @param listenerTarget    Target to attach the listener on\n   * @param handler           Handler for when the listener fires\n   * @returns                 Void\n   */\n  addInterruptiveEventListeners(listenerTarget, handler) {\n    if (!listenerTarget) {\n      listenerTarget = window;\n    }\n    this.interruptiveEvents.forEach(event => listenerTarget.addEventListener(event, handler, this.supportPassive() ? {\n      passive: true\n    } : false));\n  }\n  /**\n   * Feature-detect support for passive event listeners.\n   *\n   * @returns       Whether or not passive event listeners are supported\n   */\n  supportPassive() {\n    let supportsPassive = false;\n    try {\n      const opts = Object.defineProperty({}, 'passive', {\n        get: () => {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener('testPassive', null, opts);\n      window.removeEventListener('testPassive', null, opts);\n    } catch (e) {}\n    return supportsPassive;\n  }\n  /**\n   * Remove listeners for the Animation Interrupt Event from\n   * the Listener Target. Specifying the correct handler prevents\n   * memory leaks and makes the allocated memory available for\n   * Garbage Collection.\n   *\n   * @param events            List of Interruptive Events to remove\n   * @param listenerTarget    Target to attach the listener on\n   * @param handler           Handler for when the listener fires\n   * @returns                 Void\n   */\n  removeInterruptiveEventListeners(events, listenerTarget, handler) {\n    if (!listenerTarget) {\n      listenerTarget = window;\n    }\n    events.forEach(event => listenerTarget.removeEventListener(event, handler));\n  }\n  /**\n   * Find the first scrollable parent Node of a given\n   * Element. The DOM Tree gets searched upwards\n   * to find this first scrollable parent. Parents might\n   * be ignored by CSS styles applied to the HTML Element.\n   *\n   * @param nativeElement     The Element to search the DOM Tree upwards from\n   * @returns                 The first scrollable parent HTML Element\n   */\n  getFirstScrollableParent(nativeElement) {\n    let style = window.getComputedStyle(nativeElement);\n    const overflowRegex = /(auto|scroll|overlay)/;\n    if (style.position === 'fixed') {\n      return null;\n    }\n    let parent = nativeElement;\n    while (parent.parentElement) {\n      parent = parent.parentElement;\n      style = window.getComputedStyle(parent);\n      if (style.position === 'absolute' || style.overflow === 'hidden' || style.overflowY === 'hidden') {\n        continue;\n      }\n      if (overflowRegex.test(style.overflow + style.overflowY) || parent.tagName === 'BODY') {\n        return parent;\n      }\n    }\n    return null;\n  }\n  /**\n   * Get the Target Node to scroll to.\n   *\n   * @param id              The given ID of the node, either a string or\n   *                        an element reference\n   * @param allowBodyTag    Indicate whether or not the Document Body is\n   *                        considered a valid Target Node\n   * @returns               The Target Node to scroll to\n   */\n  getNode(id, allowBodyTag = false) {\n    let targetNode;\n    if (isString(id)) {\n      if (allowBodyTag && (id === 'body' || id === 'BODY')) {\n        targetNode = this.document.body;\n      } else {\n        targetNode = this.document.getElementById(stripHash(id));\n      }\n    } else if (isNumber(id)) {\n      targetNode = this.document.getElementById(String(id));\n    } else if (isElementRef(id)) {\n      targetNode = id.nativeElement;\n    } else if (isNativeElement(id)) {\n      targetNode = id;\n    }\n    return targetNode;\n  }\n  /**\n   * Retrieve the Listener target. This Listener Target is used\n   * to attach Event Listeners on. In case of the target being\n   * the Document Body, we need the actual `window` to listen\n   * for events.\n   *\n   * @param container           The HTML Container element\n   * @returns                   The Listener Target to attach events on\n   */\n  getListenerTarget(container) {\n    if (!container) {\n      return null;\n    }\n    return this.isDocumentBody(container) ? window : container;\n  }\n  /**\n   * Test if a given HTML Element is the Document Body.\n   *\n   * @param element             The given HTML Element\n   * @returns                   Whether or not the Element is the\n   *                            Document Body Element\n   */\n  isDocumentBody(element) {\n    return element.tagName.toUpperCase() === 'BODY';\n  }\n}\nScrollToService.ɵfac = function ScrollToService_Factory(t) {\n  return new (t || ScrollToService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID));\n};\nScrollToService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ScrollToService,\n  factory: ScrollToService.ɵfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ScrollToService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\nclass ScrollToDirective {\n  constructor(elementRef, scrollToService, renderer2) {\n    this.elementRef = elementRef;\n    this.scrollToService = scrollToService;\n    this.renderer2 = renderer2;\n    this.ngxScrollTo = DEFAULTS.target;\n    this.ngxScrollToEvent = DEFAULTS.action;\n    this.ngxScrollToDuration = DEFAULTS.duration;\n    this.ngxScrollToEasing = DEFAULTS.easing;\n    this.ngxScrollToOffset = DEFAULTS.offset;\n    this.ngxScrollToOffsetMap = DEFAULTS.offsetMap;\n  }\n  /**\n   * Angular Lifecycle Hook - After View Init\n   *\n   * @todo Implement Subscription for Events\n   *\n   * @returns void\n   */\n  ngAfterViewInit() {\n    // Test Event Support\n    if (EVENTS.indexOf(this.ngxScrollToEvent) === -1) {\n      throw new Error(`Unsupported Event '${this.ngxScrollToEvent}'`);\n    }\n    // Listen for the trigger...\n    this.renderer2.listen(this.elementRef.nativeElement, this.ngxScrollToEvent, event => {\n      this.options = {\n        target: this.ngxScrollTo,\n        duration: this.ngxScrollToDuration,\n        easing: this.ngxScrollToEasing,\n        offset: this.ngxScrollToOffset,\n        offsetMap: this.ngxScrollToOffsetMap\n      };\n      this.scrollToService.scrollTo(this.options);\n    });\n  }\n}\nScrollToDirective.ɵfac = function ScrollToDirective_Factory(t) {\n  return new (t || ScrollToDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ScrollToService), i0.ɵɵdirectiveInject(i0.Renderer2));\n};\nScrollToDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: ScrollToDirective,\n  selectors: [[\"\", \"ngxScrollTo\", \"\"]],\n  inputs: {\n    ngxScrollTo: \"ngxScrollTo\",\n    ngxScrollToEvent: \"ngxScrollToEvent\",\n    ngxScrollToDuration: \"ngxScrollToDuration\",\n    ngxScrollToEasing: \"ngxScrollToEasing\",\n    ngxScrollToOffset: \"ngxScrollToOffset\",\n    ngxScrollToOffsetMap: \"ngxScrollToOffsetMap\"\n  }\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ScrollToDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxScrollTo]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: ScrollToService\n    }, {\n      type: i0.Renderer2\n    }];\n  }, {\n    ngxScrollTo: [{\n      type: Input\n    }],\n    ngxScrollToEvent: [{\n      type: Input\n    }],\n    ngxScrollToDuration: [{\n      type: Input\n    }],\n    ngxScrollToEasing: [{\n      type: Input\n    }],\n    ngxScrollToOffset: [{\n      type: Input\n    }],\n    ngxScrollToOffsetMap: [{\n      type: Input\n    }]\n  });\n})();\n\n/** Scroll To Module */\nclass ScrollToModule {\n  /**\n   * Guaranteed singletons for provided Services across App.\n   *\n   * @return          An Angular Module with Providers\n   */\n  static forRoot() {\n    return {\n      ngModule: ScrollToModule,\n      providers: [ScrollToService]\n    };\n  }\n}\nScrollToModule.ɵfac = function ScrollToModule_Factory(t) {\n  return new (t || ScrollToModule)();\n};\nScrollToModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: ScrollToModule,\n  declarations: [ScrollToDirective],\n  exports: [ScrollToDirective]\n});\nScrollToModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ScrollToModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [ScrollToDirective],\n      exports: [ScrollToDirective]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of ngx-scroll-to\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ScrollToDirective, ScrollToModule, ScrollToService };\n"],
  "mappings": "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",
  "names": ["isWindow", "document"]
}
