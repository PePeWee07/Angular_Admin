"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotAbleToGetDistFolderPathError = exports.CouldNotBuildTheLibraryError = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const utils_1 = require("./utils");
function deploy(engine, context, buildTarget, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // This should be removed on V17. context.projectGraph is going to be required
        if (!context.projectGraph) {
            throw new Error('context.projectGraph is undefined');
        }
        const targetDescription = (0, devkit_1.parseTargetString)(buildTarget.name, context.projectGraph);
        if (options.noBuild) {
            devkit_1.logger.info(`ðŸ“¦ Skipping build`);
        }
        else {
            yield buildLibrary(context, buildTarget, targetDescription);
        }
        const buildOptions = (0, devkit_1.readTargetOptions)(targetDescription, context);
        let outputPath;
        try {
            outputPath = yield (0, utils_1.getLibOutPutPath)(context.root, buildOptions, options);
        }
        catch (error) {
            devkit_1.logger.error(error);
            throw new NotAbleToGetDistFolderPathError();
        }
        yield engine.run(outputPath, options);
    });
}
exports.default = deploy;
function buildLibrary(context, buildTarget, targetDescription) {
    var _a, e_1, _b, _c;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!context.target) {
            throw new Error('Cannot execute the build target');
        }
        devkit_1.logger.info(`ðŸ“¦ Building "${context.projectName}"`);
        devkit_1.logger.info(`ðŸ“¦ Build target "${buildTarget.name}"`);
        const buildResult = yield (0, devkit_1.runExecutor)(targetDescription, {}, context);
        try {
            for (var _d = true, buildResult_1 = tslib_1.__asyncValues(buildResult), buildResult_1_1; buildResult_1_1 = yield buildResult_1.next(), _a = buildResult_1_1.done, !_a; _d = true) {
                _c = buildResult_1_1.value;
                _d = false;
                const output = _c;
                if (!output.success) {
                    throw new CouldNotBuildTheLibraryError();
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = buildResult_1.return)) yield _b.call(buildResult_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
}
class CouldNotBuildTheLibraryError extends Error {
    constructor() {
        const errorMsg = 'Could not build the library';
        super(errorMsg);
        // Ensure the name of this error is the same as the class name
        this.name = this.constructor.name;
        // It does make the stack trace a little nicer.
        //  @see Node.js reference (bottom)
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.CouldNotBuildTheLibraryError = CouldNotBuildTheLibraryError;
class NotAbleToGetDistFolderPathError extends Error {
    constructor() {
        const errorMsg = "There is an error trying to locate the library's dist path";
        super(errorMsg);
        // Ensure the name of this error is the same as the class name
        this.name = this.constructor.name;
        // It does make the stack trace a little nicer.
        //  @see Node.js reference (bottom)
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.NotAbleToGetDistFolderPathError = NotAbleToGetDistFolderPathError;
//# sourceMappingURL=actions.js.map